Project Deployment Documentation
-------------------------------------------------------------------------------------------------------------------------
1. Project Overview
    have a Node.js backend and a React frontend application:
          Backend runs on port 8080 (Express + MySQL).
          Frontend runs on port 3000 (React served via serve).
          Both applications are containerized and stored on AWS ECR.
          Both applications are deployed on Kubernetes.
    A single Ingress routes external traffic to frontend (/) and backend (/api).
_____________________________________________________________________
2. Dockerfiles Summary
    Backend Dockerfile (node.js-backend/Dockerfile)
        FROM node:18-alpine
        WORKDIR /app
        COPY package.json package-lock.json ./
        RUN npm ci --only=production
        COPY src ./src
        EXPOSE 8080
        CMD ["node", "src/index.js"]

    Frontend Dockerfile (frontend/Dockerfile)
        FROM node:18-alpine AS build
        WORKDIR /app
        COPY package.json package-lock.json ./
        RUN npm ci
        COPY src ./src
        COPY public ./public
        RUN npm run build
    
        FROM node:18-alpine
        WORKDIR /app
        RUN npm i -g serve
        COPY --from=build /app/build /app/build
        EXPOSE 3000
        CMD ["serve", "-s", "build", "-l", "3000"]
_____________________________________________________________________
3. Kubernetes Deployment Architecture
    Component	            Image (AWS ECR)	        Port(s)        Kubernetes Service Type	Accessible At
    Backend	                shop-backend	        8080	       ClusterIP	/api via Ingress
    Frontend	            shop-frontend	        3000	       ClusterIP	/ via Ingress
    Ingress Controller	    NGINX Controller	    80 (HTTP)	   LoadBalancer	Public IP or domain
------------
deployment.yaml
------------
cat backend-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp-backend
spec:
  replicas: 2
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  selector:
    matchLabels:
      app: myapp-backend
  template:
    metadata:
      labels:
        app: myapp-backend
    spec:
      tolerations:
        - key: "app"
          operator: "Equal"
          value: "myapp"
          effect: "NoSchedule"
      containers:
        - name: myapp-backend
          image: 486408064722.dkr.ecr.us-east-1.amazonaws.com/frontend-backend-application:backend-latest
          ports:
            - containerPort: 8080
          livenessProbe:
            httpGet:
              path: /api/hello
              port: 8080
            initialDelaySeconds: 10
            periodSeconds: 5
          readinessProbe:
            httpGet:
              path: /api/hello
              port: 8080
            initialDelaySeconds: 5
            periodSeconds: 3
      imagePullSecrets:
        - name: ecr-secret
---
apiVersion: v1
kind: Service
metadata:
  name: myapp-backend-service
spec:
  selector:
    app: myapp-backend
  type: ClusterIP
  ports:
    - port: 8080
      targetPort: 8080


root@master-node:/home/ubuntu/k8s-files# cat frontend-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp-frontend
spec:
  replicas: 2
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  selector:
    matchLabels:
      app: myapp-frontend
  template:
    metadata:
      labels:
        app: myapp-frontend
    spec:
      tolerations:
        - key: "app"
          operator: "Equal"
          value: "myapp"
          effect: "NoSchedule"
      containers:
        - name: myapp-frontend
          image: 486408064722.dkr.ecr.us-east-1.amazonaws.com/frontend-backend-application:frontend-latest
          ports:
            - containerPort: 80
          livenessProbe:
            httpGet:
              path: /
              port: 80
            initialDelaySeconds: 10
            periodSeconds: 5
          readinessProbe:
            httpGet:
              path: /
              port: 80
            initialDelaySeconds: 5
            periodSeconds: 3
      imagePullSecrets:
        - name: ecr-secret
---
apiVersion: v1
kind: Service
metadata:
  name: myapp-frontend-service
spec:
  selector:
    app: myapp-frontend
  type: ClusterIP
  ports:
    - port: 80
      targetPort: 80
------------
ingress.yaml
------------
root@master-node:/home/ubuntu/k8s-files# cat myapp-ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: myapp-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  ingressClassName: nginx
  rules:
    - http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: myapp-frontend-service
                port:
                  number: 80
          - path: /api
            pathType: Prefix
            backend:
              service:
                name: myapp-backend-service
                port:
                  number: 8080

----------------
pdb.yaml
----------------
root@master-node:/home/ubuntu/k8s-files# cat frontend-pdb.yaml
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: myapp-frontend-pdb
spec:
  minAvailable: 1
  selector:
    matchLabels:
      app: myapp-frontend

root@master-node:/home/ubuntu/k8s-files# cat backend-pdb.yaml
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: myapp-backend-pdb
spec:
  minAvailable: 1
  selector:
    matchLabels:
      app: myapp-backend
____________________________________________________________________________________________________________
5. AWS ECR Setup
    The images are hosted in AWS ECR under:
        Frontend:
        48644722.dkr.ecr.us-east-1.amazonaws.com/frontend-backend-application:shop-frontend
        Backend:
        48644722.dkr.ecr.us-east-1.amazonaws.com/frontend-backend-application:shop-backend

    Create a Kubernetes secret for ECR authentication:

        aws ecr get-login-password --region us-east-1 | \
        kubectl create secret docker-registry ecr-registry \
          --docker-server=486408064722.dkr.ecr.us-east-1.amazonaws.com \
          --docker-username=AWS \
          --docker-password=$(aws ecr get-login-password --region us-east-1) \
          --namespace shop-app
____________________________________________________________________________
6. Ingress Controller Setup
    Using Helm (recommended)
        helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
        helm repo update
        
        helm install ingress-nginx ingress-nginx/ingress-nginx \
          --namespace ingress-nginx --create-namespace \
          --set controller.service.type=LoadBalancer
    
    Or via kubectl (quick setup)
        kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.9.4/deploy/static/provider/cloud/deploy.yaml
    
    Wait for the Ingress Controller's LoadBalancer to get an external IP:    
        kubectl get svc -n ingress-nginx
__________________________________________________________________________
7. Deployment Commands
    Assuming your YAML files are saved as backend.yaml, frontend.yaml, and ingress.yaml:
        kubectl create namespace shop-app
        # Create the ECR secret
        aws ecr get-login-password --region us-east-1 | \
        kubectl create secret docker-registry ecr-registry \
          --docker-server=486408064722.dkr.ecr.us-east-1.amazonaws.com \
          --docker-username=AWS \
          --docker-password=$(aws ecr get-login-password --region us-east-1) \
          --namespace shop-app

    # Deploy backend and frontend
        kubectl apply -f backend.yaml
        kubectl apply -f frontend.yaml

    # Install ingress controller if not installed
        kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.9.4/deploy/static/provider/cloud/deploy.yaml

    # Wait until ingress-nginx-controller service gets EXTERNAL-IP
    
    # Deploy ingress rules
        kubectl apply -f ingress.yaml
___________________________________________________________________________
8. Accessing the Application
    Use the EXTERNAL-IP from the ingress-nginx LoadBalancer service.
    Example URL (using nip.io wildcard):
      http://shop.<EXTERNAL-IP>.nip.io/
    Routes:
      Frontend React app: /
      Backend API: /api
___________________________________________________________________________
9. Pod Naming Convention
    Pods are created by Deployments; their names are auto-generated.
    The pod name format:  
      <deployment-name>-<replicaset-hash>-<random-suffix>
    For example:
      backend-deployment-6b947bfcf5-9zvbd
      frontend-deployment-8484f7ccbd-8slc6
    Pods get new names on rolling updates or restarts.
___________________________________________________________________________
10. Additional Notes
    Update your React frontend to call the backend API via relative path /api (not hardcoded IP), e.g.:
    fetch('/api')
    The Ingress rewrite-target annotation strips the /api prefix before forwarding to the backend.
    Use namespaces to isolate environments.
    Keep your ECR credentials secure and rotate periodically.
