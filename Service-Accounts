1️⃣ What is a Service Account?
    A Service Account (SA) is an identity used by applications or pods running inside Kubernetes to interact with the Kubernetes API.
    Unlike user accounts (humans, IAM users, OIDC users), Service Accounts are for machines—pods, controllers, jobs, etc.
    Key points:
      Each pod can use a Service Account to access the Kubernetes API securely.
      By default, every namespace has a default Service Account.

2️⃣ Why Service Accounts are needed
    Imagine you have an application running in a pod that needs to:
    Read ConfigMaps.
    Update Secrets.
    List pods in its namespace.
    You should not use a human IAM account or hard-coded credentials. Instead:
    Assign a Service Account to the pod.
    Give it limited permissions using RBAC.
    Kubernetes automatically provides credentials (tokens) to the pod.
    This ensures least privilege, security, and manageability.

3️⃣ Default Service Account

    Every namespace has a Service Account called default.  
    If you don’t specify any Service Account, pods automatically use the default SA.
    Kubernetes injects a token into /var/run/secrets/kubernetes.io/serviceaccount inside the pod.

4️⃣ How to Create a Service Account
    apiVersion: v1
    kind: ServiceAccount
    metadata:
      name: myapp-sa
      namespace: dev
    Here, myapp-sa is a new Service Account in the dev namespace.

5️⃣ Assigning a Service Account to a Pod
    apiVersion: v1
    kind: Pod
    metadata:
      name: myapp-pod
      namespace: dev
    spec:
      serviceAccountName: myapp-sa
      containers:
      - name: app
        image: myapp:latest
    This pod will use the myapp-sa Service Account instead of the default.

    Kubernetes automatically mounts a token into the pod at /var/run/secrets/kubernetes.io/serviceaccount/token.

6️⃣ Granting Permissions to a Service Account

    Service Accounts are identities, so you control what they can do using RBAC.
    Example: Give myapp-sa permission to read ConfigMaps in the dev namespace

    Role:
    apiVersion: rbac.authorization.k8s.io/v1
    kind: Role
    metadata:
      name: configmap-reader
      namespace: dev
    rules:
    - apiGroups: [""]
      resources: ["configmaps"]
      verbs: ["get", "list"]
    
    
    RoleBinding:  
    apiVersion: rbac.authorization.k8s.io/v1
    kind: RoleBinding
    metadata:
      name: bind-configmap-reader
      namespace: dev
    subjects:
    - kind: ServiceAccount
      name: myapp-sa
      namespace: dev
    roleRef:
      kind: Role
      name: configmap-reader
      apiGroup: rbac.authorization.k8s.io
    Now pods using myapp-sa can read ConfigMaps but cannot do anything else.

7️⃣ Accessing Kubernetes API from a Pod

    Inside a pod using a Service Account, you can access the Kubernetes API using the mounted token. 
    Example (inside a pod shell):
    # Token location
    TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
    # Kubernetes API server endpoint
    API_SERVER=https://$KUBERNETES_SERVICE_HOST:$KUBERNETES_SERVICE_PORT
    # List pods using curl
    curl --header "Authorization: Bearer $TOKEN" --insecure $API_SERVER/api/v1/namespaces/dev/pods
    
    Permissions are enforced via RBAC.

8️⃣ Key Points / Best Practices

    Least privilege: Create a Service Account per app and give only the necessary permissions.
    Do not use default SA for apps in production.
    Use Role/RoleBinding to control namespace-scoped access; ClusterRole/ClusterRoleBinding for cluster-wide access.
    Tokens are automatically rotated by Kubernetes for Service Accounts.
    Service Accounts can also be used for external authentication, e.g., with kubeconfig for CI/CD pipelines.
---------------------------------------------------------

---------------------------------------------------------
1️⃣ Real-Time / Everyday Analogy

    Imagine you work in a company office building:
        Human employees (users) → have their ID badges. The badge proves who they are (authentication).
        Departments / teams (roles) → define what rooms or resources they can access (authorization).
        Visitors / cleaning robots (service accounts) → are not human, but they also need to access certain rooms or equipment.
    
    For example:
    You hire a new employee Alice → give her badge. She can enter HR, Dev, and Cafeteria. 
    You have a coffee machine robot that refills coffee automatically:
    
        It’s not human → it doesn’t have a badge like Alice. 
        You create a robot ID card (Service Account) for it.
        You tell security: “This robot can only enter the kitchen and storage room” → this is like RBAC permissions.
    
    So in this analogy:
    
        Employee badge = IAM user / kubeconfig
        Robot ID = Service Account 
        Rooms you can enter = Kubernetes resources (pods, configmaps, secrets)
    
    The key point: Service Accounts are identities for programs/pods, not humans.
